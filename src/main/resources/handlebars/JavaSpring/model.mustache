##
package {{basePackage}}.entities;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.PrePersist;
import javax.persistence.PreUpdate;
import javax.persistence.Table;

import {{basePackage}}.entities.base.{{classname}}Base;

/**
 * This class represents a {#lowercase}{{classname}}{/lowercase}.
 */
@Entity
@Table(name = "{#lowercase}{{classname}}{/lowercase}")
public class {{classname}} extends {{classname}}Base {

	public {{classname}}() {
		super();
	}

	@PrePersist
    @Override
	public void onCreate() {
		super.onCreate();
	}

	@PreUpdate
    @Override
	public void onUpdate() {
		super.onUpdate();
	}
}

##Base
package {{basePackage}}.entities.base;

import java.io.Serializable;

import javax.persistence.Column;
import javax.persistence.EnumType;
import javax.persistence.Enumerated;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.MappedSuperclass;
import javax.persistence.PrePersist;
import javax.persistence.PreUpdate;

import java.time.OffsetDateTime;
import java.util.UUID;

import org.hibernate.annotations.Type;
import org.hibernate.annotations.TypeDef;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.vladmihalcea.hibernate.type.json.JsonType;

/**
 * This class represents a {#lowercase}{{classname}}{/lowercase} base.
 */
@MappedSuperclass
@TypeDef(name = "json", typeClass = JsonType.class)
public class {{classname}}Base implements Serializable {

{{#models}}
{{#model}}
{{#vars}}
	private {{{datatype}}} {{name}};
{{/vars}}
{{/model}}
{{/models}}

	public {{classname}}Base() {
		super();
	}

	@PrePersist
	public void onCreate() {
	}

	@PreUpdate
	public void onUpdate() {
	}

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
{{#models}}
{{#model}}
{{#vars}}
{{#isObject}}
	@Type(type = "json")
	@Column(name = "{{name}}", columnDefinition = "json")
{{/isObject}}
{{^isObject}}
	@Column(name = "{{name}}")
{{/isObject}}
	public {{{datatype}}} get{#uppercase}{{name}}{/uppercase}() {
		return {{name}};
	}

	public void set{#uppercase}{{name}}{/uppercase}({{{datatype}}} {{name}}) {
		this.{{name}} = {{name}};
	}

{{/vars}}
{{/model}}
{{/models}}

}

##Controller
package {{basePackage}}.controllers;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.constraints.NotNull;
import javax.validation.Valid;

import org.modelmapper.ModelMapper;
import org.springframework.data.domain.Page;
import org.springframework.http.MediaType;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.CookieValue;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.bind.annotation.RestController;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;

import {{basePackage}}.controllers.dtos.{{classname}}Dto;
import {{basePackage}}.controllers.helpers.RequestHandler;
import {{basePackage}}.entities.{{classname}};
import {{basePackage}}.services.{{classname}}Service;

@RestController
public class {{classname}}Controller {

	@Resource
	private ModelMapper mapper;

	@Resource
	private {{classname}}Service {#lowercase}{{classname}}{/lowercase}Service;

}

##Dto
package {{basePackage}}.controllers.dtos;

import java.util.UUID;

import java.time.OffsetDateTime;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Null;

import {{basePackage}}.controllers.helpers.CreateOperation;
import {{basePackage}}.controllers.helpers.UpdateOperation;
import {{basePackage}}.entities.{{classname}};

import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * This class represents the data transfer object of an {@link "{{classname}}"}.
 */
public class {{classname}}Dto {

{{#models}}
{{#model}}
{{#vars}}
	private {{{datatype}}} {{name}};
{{/vars}}
{{/model}}
{{/models}}

	@Null(groups = CreateOperation.class)
	@NotNull(groups = UpdateOperation.class)
{{#models}}
{{#model}}
{{#vars}}
	public {{{datatype}}} get{#uppercase}{{name}}{/uppercase}() {
		return {{name}};
	}

	public void set{#uppercase}{{name}}{/uppercase}({{{datatype}}} {{name}}) {
		this.{{name}} = {{name}};
	}
	
{{/vars}}
{{/model}}
{{/models}}
}

##Dao
package {{basePackage}}.daos;

import org.springframework.data.jpa.repository.JpaRepository;

import {{basePackage}}.daos.repositories.{{classname}}Repository;
import {{basePackage}}.entities.{{classname}};

/**
 * This class represents the data access object of a {@link "{{classname}}"}.
 */
public interface {{classname}}Dao extends JpaRepository<{{classname}}, Long>, {{classname}}Repository {

}

##Repository
package {{basePackage}}.daos.repositories;

import java.util.Map;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;

import {{basePackage}}.entities.{{classname}};

/**
 * This class represents the Hibernate data access object of a {@link "{{classname}}"}.
 */
public interface {{classname}}Repository {
	Page<{{classname}}> filterAdvanced(Map<String, Object> filter, Pageable pageable, Integer limit);
	Page<{{classname}}> filterBasic(String filter, Pageable pageable, Integer limit);
}

##RepositoryImpl
package {{basePackage}}.daos.repositories.impl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;

import {{basePackage}}.daos.repositories.{{classname}}Repository;
import {{basePackage}}.entities.{{classname}};

/**
 * This class represents the Hibernate data access object of a {@link "{{classname}}"}.
 */
public class {{classname}}RepositoryImpl implements {{classname}}Repository {
	
	@PersistenceContext
	EntityManager entityManager;

	@Override
	public Page<{{classname}}> filterAdvanced(Map<String, Object> filter, Pageable pageable, Integer limit) {
		
		List<{{classname}}> results = Collections.emptyList();
		
		String sql = "SELECT * from `{#lowercase}{{classname}}{/lowercase}` WHERE ";
		for (Map.Entry<String, Object> entry : filter.entrySet()) {
			sql += "`" + entry.getKey() + "`=`" + entry.getValue() + "` AND ";
		}
		if (sql.endsWith(" AND ")) {
			sql = sql.substring(0, sql.length() - 5);
		}
		if (limit > 0) {
			sql += " LIMIT " + limit;
		}
		
		results = entityManager.createNativeQuery(sql, {{classname}}.class).getResultList();
		
		int total = results.size();
		int start = (int)pageable.getOffset();
		int end = Math.min((start + pageable.getPageSize()), total);
		
		List<{{classname}}> output = new ArrayList<>();
		
		if (start <= end) {
			output = results.subList(start, end);
		}
		
		return new PageImpl<>(results, pageable, pageable.getPageSize());
	}

	@Override
	public Page<{{classname}}> filterBasic(String filter, Pageable pageable, Integer limit) {
	
		List<{{classname}}> results = Collections.emptyList();
		
		String sql = "SELECT * from `{#lowercase}{{classname}}{/lowercase}` ";

		if (limit > 0) {
			sql += " LIMIT " + limit;
		}

		results = entityManager.createNativeQuery(sql, {{classname}}.class).getResultList();
		
		int total = results.size();
		int start = (int)pageable.getOffset();
		int end = Math.min((start + pageable.getPageSize()), total);
		
		List<{{classname}}> output = new ArrayList<>();
		
		if (start <= end) {
			output = results.subList(start, end);
		}
		
		return new PageImpl<>(results, pageable, pageable.getPageSize());
	}
}


##Service
package {{basePackage}}.services;

import java.util.List;
import java.util.Map;

import org.springframework.data.domain.Page;
import {{basePackage}}.controllers.helpers.RequestParam;
import {{basePackage}}.entities.{{classname}};

/**
 * This interface represents the {#lowercase}{{classname}}{/lowercase}s service.
 */
public interface {{classname}}Service {

	/**
	 * Returns the {#lowercase}{{classname}}{/lowercase}s using pagination and filtered.
	 * @param page - the page
	 * @param size - the page size
	 * @param limit - the search limit
	 * @param sortField - the sorting field
	 * @param sortOrder - the sorting order
	 * @param filter - the filter model
	 * @return the {#lowercase}{{classname}}{/lowercase}s
	 */
	Page<{{classname}}> list(Integer page, Integer size, Integer limit, String sortField, Boolean sortOrder, {{classname}} filter);

	/**
	 * Returns the {#lowercase}{{classname}}{/lowercase}s using pagination and filtered by params.
	 * @param page - the page
	 * @param size - the page size
	 * @param limit - the search limit
	 * @param sortField - the sorting field
	 * @param sortOrder - the sorting order
	 * @param filter - the advanced params
	 * @return the {#lowercase}{{classname}}{/lowercase}s
	 */
	Page<{{classname}}> list(Integer page, Integer size, Integer limit, String sortField, Boolean sortOrder, List<RequestParam>  filter);

	/**
	 * Returns the {#lowercase}{{classname}}{/lowercase}s using pagination and filtered by text.
	 * @param page - the page
	 * @param size - the page size
	 * @param limit - the search limit
	 * @param sortField - the sorting field
	 * @param sortOrder - the sorting order
	 * @param filter - the filter text
	 * @return the {#lowercase}{{classname}}{/lowercase}s
	 */
	Page<{{classname}}> list(Integer page, Integer size, Integer limit, String sortField, Boolean sortOrder, String filter);
	
	/**
	 * Returns all {#lowercase}{{classname}}{/lowercase}s filtered.
	 * @return the {#lowercase}{{classname}}{/lowercase}s filtered
	 */
	List<{{classname}}> list({{classname}} filter);
	
	/**
	 * Returns all {#lowercase}{{classname}}{/lowercase}s.
	 * @return the {#lowercase}{{classname}}{/lowercase}s
	 */
	List<{{classname}}> list();

	/**
	 * Returns a {#lowercase}{{classname}}{/lowercase}.
	 * @param id - the {#lowercase}{{classname}}{/lowercase} id
	 * @return the {#lowercase}{{classname}}{/lowercase}
	 */
	{{classname}} get(Long id);

	/**
	 * Returns the current {#lowercase}{{classname}}{/lowercase}.
	 * @return the current {#lowercase}{{classname}}{/lowercase}
	 */
	//{{classname}} get();

	/**
	 * Creates a {#lowercase}{{classname}}{/lowercase}.
	 * @param {#lowercase}{{classname}}{/lowercase} - the {#lowercase}{{classname}}{/lowercase} to be created
	 * @return the {#lowercase}{{classname}}{/lowercase}
	 */
	{{classname}} create({{classname}} {#lowercase}{{classname}}{/lowercase});

	/**
	 * Updates a {#lowercase}{{classname}}{/lowercase}
	 * @param {#lowercase}{{classname}}{/lowercase} - the {#lowercase}{{classname}}{/lowercase} to be updated
	 * @return the {#lowercase}{{classname}}{/lowercase}
	 */
	{{classname}} update({{classname}} {#lowercase}{{classname}}{/lowercase});

	/**
	 * Deletes a {#lowercase}{{classname}}{/lowercase}
	 * @param id - the {#lowercase}{{classname}}{/lowercase} id
	 */
	void delete(Long id);

}

##ServiceImpl
package {{basePackage}}.services.impl;

import java.util.List;
import java.util.Map;
import javax.annotation.Resource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Example;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import {{basePackage}}.Properties;
import {{basePackage}}.controllers.helpers.RequestParam;
import {{basePackage}}.daos.{{classname}}Dao;
import {{basePackage}}.entities.{{classname}};
import {{basePackage}}.exceptions.DuplicateException;
import {{basePackage}}.exceptions.NotFoundException;
import {{basePackage}}.security.AuthService;
import {{basePackage}}.services.{{classname}}Service;

@Service
public class {{classname}}ServiceImpl implements {{classname}}Service {

	private static final Logger LOGGER = LoggerFactory.getLogger({{classname}}ServiceImpl.class);

	@Resource
	private AuthService authService;

	@Autowired
	private Properties properties;

	@Resource
	private {{classname}}Dao {#lowercase}{{classname}}{/lowercase}Dao;

	@Override
	@Transactional(readOnly = true)
	public Page<{{classname}}> list(Integer page, Integer size, Integer limit, String sortField, Boolean sortOrder, {{classname}} filter) {
		LOGGER.info("{}: list {{classname}} - page: {}, size: {}", authService.getLogId(), page, size);
		final Pageable pageable = PageRequest.of(page, size, sortOrder ? Direction.ASC : Direction.DESC, sortField);
		return {#lowercase}{{classname}}{/lowercase}Dao.findAll(Example.of(filter), pageable);
	}

	@Override
	@Transactional(readOnly = true)
	public Page<{{classname}}> list(Integer page, Integer size, Integer limit, String sortField, Boolean sortOrder, List<RequestParam> filter) {
		LOGGER.info("{}: list {{classname}} - page: {}, size: {}", authService.getLogId(), page, size);
		final Pageable pageable = PageRequest.of(page, size, sortOrder ? Direction.ASC : Direction.DESC, sortField);
		return {#lowercase}{{classname}}{/lowercase}Dao.filterAdvanced(filter, pageable, limit);
	}

	@Override
	@Transactional(readOnly = true)
	public Page<{{classname}}> list(Integer page, Integer size, Integer limit, String sortField, Boolean sortOrder, String filter) {
		LOGGER.info("{}: list {{classname}} - page: {}, size: {}", authService.getLogId(), page, size);
		final Pageable pageable = PageRequest.of(page, size, sortOrder ? Direction.ASC : Direction.DESC, sortField);
		return {#lowercase}{{classname}}{/lowercase}Dao.filterBasic(filter, pageable, limit);
	}

	@Override
	@Transactional(readOnly = true)
	public List<{{classname}}> list({{classname}} {#lowercase}{{classname}}{/lowercase}Filter) {
		LOGGER.info("{}: list {{classname}}", authService.getLogId());
		return {#lowercase}{{classname}}{/lowercase}Dao.findAll(Example.of({#lowercase}{{classname}}{/lowercase}Filter));
	}

	@Override
	@Transactional(readOnly = true)
	public List<{{classname}}> list() {
		LOGGER.info("{}: list {{classname}}", authService.getLogId());
		return {#lowercase}{{classname}}{/lowercase}Dao.findAll();
	}

	@Override
	@Transactional(readOnly = true)
	public {{classname}} get(Long id) {
		LOGGER.info("{}: get {{classname}}, {{classname}} Id: {}", authService.getLogId(), id);
		return {#lowercase}{{classname}}{/lowercase}Dao.findById(id).orElseThrow(() -> new NotFoundException("{#lowercase}{{classname}}{/lowercase} not found"));
	}

	//@Override
	//@Transactional(readOnly = true)
	//public {{classname}} get() {
	//	{{classname}} {#lowercase}{{classname}}{/lowercase} = {#lowercase}{{classname}}{/lowercase}Dao.findById(authService.get{{classname}}Id()).orElseThrow(() -> new NotFoundException("{#lowercase}{{classname}}{/lowercase} not found"));
	//
	//	return {#lowercase}{{classname}}{/lowercase};
	//}

	@Override
	@Transactional
	public {{classname}} create({{classname}} {#lowercase}{{classname}}{/lowercase}) {
		LOGGER.info("{}: create {{classname}}", authService.getLogId());
	
		validate({#lowercase}{{classname}}{/lowercase});

		return {#lowercase}{{classname}}{/lowercase}Dao.save({#lowercase}{{classname}}{/lowercase});
	}

	@Override
	@Transactional
	public {{classname}} update({{classname}} {#lowercase}{{classname}}{/lowercase}) {
		LOGGER.info("{}: update {{classname}}, {{classname}} Id: {}", authService.getLogId(), {#lowercase}{{classname}}{/lowercase}.getId());

		validate({#lowercase}{{classname}}{/lowercase});
		
		// save ({#lowercase}{{classname}}{/lowercase})
		{{classname}} stored{{classname}} = {#lowercase}{{classname}}{/lowercase}Dao.findById({#lowercase}{{classname}}{/lowercase}.getId()).orElseThrow(() -> new NotFoundException("{{classname}} not found"));

{{#models}}
{{#model}}
{{#vars}}
{{^@first}}
		stored{{classname}}.set{#uppercase}{{name}}{/uppercase}({#lowercase}{{classname}}{/lowercase}.get{#uppercase}{{name}}{/uppercase}());
{{/@first}}
{{/vars}}
{{/model}}
{{/models}}

		return {#lowercase}{{classname}}{/lowercase}Dao.save(stored{{classname}});
	}	

	@Override
	@Transactional
	public void delete(Long id) {
		LOGGER.info("{}: delete {{classname}}, {{classname}} Id: {}", authService.getLogId(), id);

		{{classname}} stored{{classname}} = {#lowercase}{{classname}}{/lowercase}Dao.findById(id).orElseThrow(() -> new NotFoundException("{#lowercase}{{classname}}{/lowercase} not found"));

		{#lowercase}{{classname}}{/lowercase}Dao.delete(stored{{classname}});
	}

	/**
	 * Validates a {#lowercase}{{classname}}{/lowercase}.
	 * @param {#lowercase}{{classname}}{/lowercase} - the {#lowercase}{{classname}}{/lowercase}
	 */
	private void validate({{classname}} {#lowercase}{{classname}}{/lowercase}) {
	}

}
